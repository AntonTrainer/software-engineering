
Working Classes
Class Foundations: Abstract Data Types (ADTs)
ADT is collection of data and operations to do work on that data
Without understanding ADTs, programmers create classes that are
"classes" in name only - in reality, they are little more than
convenient carrying cases for loosely related collections of data and
routines.
With an understanding of ADTs, programmers can create classes that are 
easier to implement initially and easier to modify over time.
Main idea is giving yourself the ability to work in the problem domain
rather than at the low level implementation domain.

------------------------------------------------------------------------
Example of the Need for an ADT
Suppose writingt a program to control text output to the screen using a
variety of typefaces, point sizes, and font attributes.
If you use an ADT, youll have a group of font routines bundled with the
data they operate on. The collection of font routines and data is an ADT

If not using an ADT, youll need an ad hoc approach to manipulating fonts
    --> currentFont.size = 16
If you have a collection of library routines, code may be slightly more
    readable
    --> currentFont.size = PointsToPixels(12)
Or could provide a more specific name for the attribute
    --> currentFont.sizeInPixels = PointsToPixels(12)

But what you cant do is have both currentFont.sizeInPixels and
currentFont.sizeInPoints, because if both in play, then currentFont wont
have any way to know which of the two to use.

------------------------------------------------------------------------
Benefits of Using ADTs
The problem with the ad hoc approach isnt that its bad practice. Rather,
its that you can replace the approach with a better programming practice
that produces these benefits:
    - You can hide implementation details
    - Changes dont affect the whole program
    - You can make the interface more informative
    - Its easier to improve performance
    - The program is more obviously correct
    - The program becomes more self documenting
    - You dont have to pass data all over your program
    - Youre able to work with real world entities rather than low level
        implementation structures

currentFont.SetSizeInPoints(sizeInPoints)
currentFont.SetSizeInPixels(sizeInPixels)
currentFont.SetBoldOn()
currentFont.SetBoldOff()
currentFont.SetItalicOn()
currentFont.SetItalicOff()
currentFont.SetTypeFace(faceName)

------------------------------------------------------------------------
More Examples of ADTs
Light
    turn on
    turn off

Blender
    turn on
    turn off
    set speed

Fuel Tank
    fill tank
    drain tank
    get tank capacity
    get tank status

Stacks, Lists, Queues


------------------------------------------------------------------------
ADTs and Classes
One way of thinking of a class is as an abstract data type plus 
inheritence and polymorphism (same interface for differing underlying
data types) --> __repr__, __add__, etc definitions

Good Class Interfaces

Good Abstraction
Every routine in the interface is working towards consistent end within
the scope of the abstraction

Bad Abstrction
Miscellaneous collection of functions

Each class should implement one and only one ADT, or if you cant 
determine what ADT the class implements, its time to reorganize the 
class into one or more well-defined ADTs

Bad
    Public:
    void addEmployee(Employee)      1 Employee
    void removeEmployee(Employee)   1

    Employee NextItemInList()       2 List Item
    Employee FirstItem()            2
    Emplyee LastItem()              2

Good
    Public:
    void addEmployee(Employee)      1 Employee
    void removeEmployee(Employee)   1  
    Employee NextEmployee()         1
    Employee FirstEmployee()        1
    Employee LastEmployee()         1

    Private:
    ListContainer m_EmployeeList    2 the class used is now hidden


Provide service in pairs, if you have an operation, there is usually an
opposite or inverse operation

Make interfaces programatic, not semantic
Programmatic part consists of data types and other attributes that can
be enforced by a compiler
Semantic part is the assumptions about how the interface will be used
that cannot be enforced by a compiler (proper initialization, seuqnces)
    - The semantic interface should be well documented
    - Look for ways to convert semantic elements to programatic by
    using Asserts or other techniques

Beware of erosion of the interfaces abstraction under modification
DONT ADD PUBLIC INTERFACE ROUTINES THAT ARE OUT OF LINE WITH ORIGINAL
PURPOSE AND CLASS-IFICATION

------------------------------------------------------------------------
Good Encapsulation

Minimize accessability
Dont expose member data in public
    --> use getters and setters
Avoid putting private implementation details into a classes interface
Dont make assumptions about the class's users
    - should be designed and implemented to adhere to the contract 
        implied by the class interface
Avoid friend classes (actual thing, not a metaphor)
Dont put a routine into the public interface just because it uses only
    public routines
Favor read-tim convenience to write-time convenience
    - code is read far more times than it is written
Dont do semantic violations
"It aint abstract if you have to look at the underlying implementation
to understand whats going on"

