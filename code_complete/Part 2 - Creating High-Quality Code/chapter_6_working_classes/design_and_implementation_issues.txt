
Design and Implementation Issues

Defining good class interfaces goes a long way towards creating a
high quality program

The internal class design and implementations are also important.

------------------------------------------------------------------------
Containment - ("has a" Relationships)
Containment is the simple idea that a class contains a primitive data
element of object.
More is written about inheritence b/c its difficult, but Containment 
still slaps

"has a"
employee has a phone number
    has a name
    has a tax ID

Implement "has a" through private inheritence as a last resort
Limit yourself to 7+-2 data members

------------------------------------------------------------------------
Inheritance - ("is a" Relationships)
Inheritence is the idea that one class is a specialization of another
class.
The purpose of inheritence is to create simpler code by defining a base
class that specifies common elements of two or more derived classes.
The common elements can be
    - routine interfaces
    - implementations
    - data members
    - data types

When deciding to use, need to make several decisions:
    - For each member routine, will the routine be visible to derived
        classes? Will it have a default implementation? Will the default
        implementation be overridable?
    - For each data member (including variables, named constants, 
        enumerations, and so on), will the data member be visible to
        derived classes?

How to make these decisions:
Implement "is a" through public interface
    - if the derived class isnt going to adhere COMPLETELY to the same
        interface contract defined by the base class, inheritence 
        is not the right technique
"Design and document for inheritance, or prohibit it"

Inherited routines
- Abstract overridable routine: means the derived class inherits from
    the routines interface, but not its implementation
- Overridable routine: means that the derived class inherits the 
    routines interface and a default implementation and it is allowed to
    override the default implementation
- Non-overriable routine: means that the derived class inherits the 
    routines interface and its defautl implementation and is not allowed
    to override the routines implementation
"dont reuse names of non-overridable base-class routines in derived
classes"

Other rules of thumb:
- Move common interfaces, data and behavior as high as possible in the
inheritence tree. The higer you move interfaces, data and behavior, 
the more easily derived classes can use them
- Be suspicious of classes of which there is only one instance. A single
instance might indicate that the design confuses objects with classes.
Can the variation of the derived class be represented in data rather 
than as a distinct class?
- Be suspicious of base classes of which there is only one derived class
- Be suspicious of classes that override a routine and do nothing inside
the derived routine
--> Fix the base class to handle variations in derived

Multiple Inheritence
Is a thing, but gets overly complex easily
(very short section on this saying to stay away from it, lmao)

------------------------------------------------------------------------
Member Functions and Data
Guidelines:
Keep number of routines in a class as small as possible
    --> higher number of routines per class are associated with higher
        fault rates
Disallow implicitly generated member functions and operators you dont
want
Minimize the number of different routines called by a class
    --> Higher fault rates correlate to the total number of routines
        called from within a class
    --> The more classes a class uses, the higher its fault rates
Minimize indirect routine calls to other classes
    --> account.ContactPerson().DaytimeContactInfo().PhoneNumber() = BAD

Basically:
- Minimise the number of kinds of object instantiated
- Min number of different direct routine calls on instantiated objects
- Min num of routine calls on objects returned by other instantiated obj

------------------------------------------------------------------------
Constructors
Guidelines:
Initialize all member data in all constructors
Enforce singleton property by using a private constructor
Prefer deep copies to shallow copies until proven otherwise

