
Design in Construction
Loose definition of design though

Design Challenges
Usually you will need to solve part of the problem before the whole 
problem can be clearly defined

- Design is a sloppy process (even if it produces a tidy result)
    - lots of mistakes
- Design is about tradeoffs and priorities
- Design involves restrictions
- Design is non deterministic (many ways to skin a cat)
- Design is a heuristic process, rules of thumb that work get reused
- Design is emergent, things grow spontaneously after spending more
    and more time with the code seeing whats possible

Key Design Concepts

1) Softwares Primary Technical Imperative: Managing Complexity
Accidential and Essential Difficulties
- Essential ones are like difficulties interfacing with real world
- Accidential is like implementation errors

Managing Complexity
- When a project reaches the point where nobody completely understands
    the impact their code changes have, that is bad haha
- There are two ways of constucting a software design: make it so simple
    that there are obbviously no deficiencies, or to make it so
    complicated that there are no obvious deficiencies
- Goal is to minimize the amount of a program you have to think about
    at any one time
- Write code that compensates for inherent human limitations

How to Attack Complexity
Overly costly, ineffective designs arise from three sources:
    - A complex solution to a simple problem
    - A simple, incorrect solution to a complex problem
    - An inappropriate, complex solution to a complex problem
Two-pronged approach to managing:
    - Minimize amount of essential complexity that anyones brain has to
        deal with at any one time
    - Keep accidential complexity from needlessly proliferating

Once you understand that all other technical goals in software are 
secondary to managing complexity, many design considerations become
straightforward.

2) Desirable Characteristics of a Design
Minimal complexity
- avoid "clever" designs
    --> clever designs are usually hard to understand
    --> instead, make "simple" and "easy-to-understand" designs
- easy maintenance
- loose coupling
    --> connections amond different parts of a program to a minimum
    - good abstractions in class interfaces
    - encapsulation
- extensibility
    --> enhance a system withouth changes causing violence to underlying
        structure or other pieces
- reusability
- high fan-in
    --> high number of classes that use a given class
    - high fan-in means that a system has been designed to make good use
        of utility classes at the lower levels in the system
- low-medium fan-out
    --> given class uses low number of other classes (>7 is high)
- portability
    --> can be easily moved to another environment
- leanness
    --> a book is not finished when nothing more can be added, rather
        it is when nothing more can be taken away
- stratification
    --> keep levels of decomposition stratified so you can view the 
        system at any single level and get a consistent view
    - view at one level without dipping into other levels
    - compartmentalize code, create good interface
- standard technique
    - the more a system relies on exotic practices, the more
        intimidating it will be for someone to try and understand

3) Levels of Design
see levels_in_design.txt

