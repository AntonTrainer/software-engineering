# Chapter 16: No Silver Bullet - Essence and Accident in Software Engineering

## Abstract

* Most gains in software productivity have come from removing artifical barries that made the accidential tasks inordinately hard
  * Severe hardware constraints
  * Awkward programming languages
  * Lack of machine time
* Suggestions:
  * Exploit the mass market to avoid constructing what can be bought
  * Use rapid prototyping as part of a planned iteration in establishing software requirements
  * Grow software organically, adding more and more function to systems as they are run, used, and tested
  * Identify and develop the great conceptual designers of the rising generation

## Introduction

* Werewolves are scary cause something ordinary and loved gets scary real fast and can only be put down with a silver bullet haha
* Progress towards taming these monsters comes one step at a time and through great perserverence
  * Like disease management

## Does It Have to Be Hard? - Essential Difficulties

* Some difficulties are in the *essence* of software
  * Baked into its very nature
* Others are *accidents*
  * That which are found, but not inherent
* Software is a construct of interlocking concepts
  * Data sets
  * Relationships among data items
  * Algorithms
  * Invocation of functions

"I believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the labor of representing it and testing the fidelity of the representation."

## Inherent properties and essence of modern software systems
  * Complexity
  * Conformity
  * Changeability
  * Invisibility

### Complexity

* Software entities arae much more complex than other human made things of their size

### Conformity

* Much of the complexity a software engineer must master is arbitrary
  * Forced without rhyme or reason by the many human institutions
  * These were designed by people, not God
* Software can either conform because:
  * It is the most recent to the scene
  * Or it is viewed as the most conformable
* In both cases, complexity is the result of conforming to other interfaces

### Changeability

* The software entity is constantly subject to pressures for change
* Because it can be changed more easily than physical beings, it is considerred more malliable
* Software is subject to the cultural matrix of applications, users, laws, and machine vehicles - all of which are constantly changing as well

### Invisibility

* Software is invisible and unvisualizable
* Cannot use traditional geometrics to embed software in space
* This lack of visualization impedes communication between minds

## Past Breakthroughs Solved Accidential Difficulties

* Most big breakthroughs have come about from addressing Accidential, not Essential, difficulties

### High Level Languages

* Frees a program from much accidential complexity
* Help establish conceptual constructs
  * Operations
  * Data types
  * Sequences
  * Communication

### Time-sharing

* Folks working on the same machine was a big help
* Not partitioning worktimes and breaking headspace is huge

### Unified Programming Environments

* Using programs together is huge
* Providing integrated libraries, file formats, pipes and filters was big
* Resulted in Environments that have become central focus of todays software engineering research

## Hopes for the Silver

* Technical developments that have been considered silver bullets in the past

### Ada and Other High-Level Language Advances

* Introduced some good stuff, but like any other high level language only reduces accidential complexity

### Object-Oriented Programming

* This is the most optimistic 'fad'
* Encompasses
  * Abstract data types
  * Hierarchical types
  * aka Classes
* No matter how good OOP gets, it still doesnt address design complexity - which is essential

### Artificial Intelligence

* Has been touted as this great thing
* The author doesnt think itll help much hahaha
* AI has two tiers:
  * AI-1
    * The use of computers to solve problems that previously could only be solved by applying human intelligence
    * Voice recognition, CV, NLP
  * AI-2
    * The use of a specific set of programming techniques known as heuristics or rule-based programming to solve problems the way humans seem to solve them
    * These are known as **Expert Systems**

#### Expert Systems

* An expert system is a program containint a generalized inference engine and a rule base, designed to take input data and explore the logical consequences throught the interface
* The power of these systems lie not in fancier inference mechanisms, rather ever richer knowledge bases that reflec the real world more accurately
* The most powerful contribution will be to inexperienced programmers that can benefit from the accumulated wisdom of the best programmers
  * This is a great gift
  * The gap between the best software engineering practice and the average practice is very wide
    * Perhaps wider than in any other engineering discipline

### "Automatic" Programming

* The dream of a generated program at the command of a problem
* Essentially, is a euphamism for programming with a higher-level language than what was presently available to the programmer
* There are tools to aid in this
  * Works best when applications are
    * Readily characterized by relatively few parameters
    * There are many known methods of solution to provide a library of alternatives
    * Extensive analysis has led to explicit rules for selecting solution techniques, given problem parameters

### Graphical Programming

* Flow charts are the closest thing
* Many hate these charts haha
  * "The flow chart is a very poor abstraction of software structure"

### Program Verification

* Attacking bugs in the system design phase has been lusted after
* However, addressing this does not reduce manpower

### Environments and Tools

* Most low hanging fruit has been addressed already
* Return from now on is marginal haha

### Workstations

* More powerful workstations are hype
* Not gonna produce any magical enhancements

## Promising Attachs on the Conceptual Essence

### Buy vs Build

* The most radical possible solution for constructing software is not to contruct it at all
* Even at a cost of $100,000, a purchased piece of software is costing only as much as one programmer year
  * And delivery is immediate!

### Requirements Refinement and Rapid Prototyping

* The single hardest part of building a software system is deciding what to build
  * Establishing detailed technical requirements is no small task
* Clients usually dont know what they want haha
* But, if can simulate important components, they truly help the client figure out what feels right

### Incremental Development - Grow, not build, Software

* The brain grows
* Morale effects are good too
  * Something about having a working system

### Great Designers

* Study after study shows that the very dest designers produce structures that are faster, smaller, simpler, cleaner, and produced with less effort
* Make organizational proclamations that:
  * Great designers are as important to their success as great managers
  * Both can be expected to be similarly nurtured and rewarded
  * Must be fully equivalent - salry, office size, travel funds, staff support
* How to grow great designers?
  * Systematically identify top designers as early as possible
    * The best are often not the most experienced
  * Assign a career mentor to be responsible for the development of the prospect, and keep a careful career file
  * Devise and maintain a career development plan for each prospect, including carefully selected apprenticeships with top designers, episodes of advanced formal education, and short course, all interspersed with solo design and technical leadership assignments
  * Provide opportunities for growing designers to interact with and stimulate each other
